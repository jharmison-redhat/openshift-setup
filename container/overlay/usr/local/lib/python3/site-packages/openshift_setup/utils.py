import logging
import logging.handlers
import os
import shlex
import subprocess
import sys

from typing import Dict, Iterable

from .exceptions import ShellRuntimeException
from .vars import vars


def make_logger(verbosity: int | None = None) -> logging.Logger:
    """Make a consistent logger that respects persistent verbosity settings."""
    logger = logging.getLogger("openshift-setup")
    logger.setLevel(logging.DEBUG)

    if len(logger.handlers) ==0:
        _format = "{asctime} {name} [{levelname:^9s}]: {message}"
        formatter = logging.Formatter(_format, style="{")

        stderr = logging.StreamHandler(stream=sys.stderr)
        stderr.setFormatter(formatter)
        if verbosity is not None:
            stderr.setLevel(40 - (min(3, verbosity) * 10))
        else:
            stderr.setLevel(40)
        logger.addHandler(stderr)
    else:
        if verbosity is not None:
            stderr = logger.handlers[0]
            # Never lower the verbosity after it's been made high
            stderr.setLevel(min(stderr.level, 40 - (min(3, verbosity) * 10)))

    return logger


logger = make_logger()


def merge(a: dict, b: dict, path: list | None = None):
    if path is None:
        path = []
    for key in b:
        if key in a:
            if isinstance(a[key], dict) and isinstance(b[key], dict):
                merge(a[key], b[key], path + [str(key)])
            elif isinstance(a[key], list) and isinstance(b[key], list):
                logger.debug(f"Extending {a[key]} with {b[key]} at {path + [str(key)]}")
                a[key].extend([v for v in b[key] if v not in a[key]])
            else:
                logger.debug(f"Replacing {a[key]} with {b[key]} at {path + [str(key)]}")
                a[key] = b[key]
        else:
            a[key] = b[key]
    return a


def _utf8ify(line_bytes: bytes | None = None) -> str:
    """Decode line_bytes as utf-8 and strips excess whitespace."""
    if line_bytes is not None:
        return line_bytes.decode("utf-8").rstrip()
    else:
        return ""


def shell(cmd: str = "",
          fail: bool = True,
          stderr: int | None = subprocess.STDOUT,
          env: Dict[str, str] = merge(os.environ.copy(), vars)) -> Iterable[str]:
    """Run a command in a subprocess, yielding lines of output from it.
    By default will throw an Exception depending on  the return code of the
    command. To change this behavior, pass fail=False.
    """
    logger.debug("Running: {}".format(cmd))
    proc = subprocess.Popen(
        shlex.split(cmd),  # nosec
        stdout=subprocess.PIPE,
        stderr=stderr,
        env=env,
    )

    last_line = None
    assert proc.stdout is not None
    for line in map(_utf8ify, iter(proc.stdout.readline, b"")):
        last_line = line
        yield line

    ret = proc.wait()
    if fail and ret != 0:
        logger.error("Command errored: {}".format(cmd))
        raise ShellRuntimeException(ret, last_line)
    elif ret != 0:
        logger.warning("Command returned {}: {}".format(ret, cmd))


def shellw(cmd: str = "",
          fail: bool = True,
          stderr: int | None = subprocess.STDOUT,
          env: Dict[str, str] = merge(os.environ.copy(), vars)) -> str:
    """Run a command in a subprocess, wait for it to finish, return all
    lines from it as a single string."""
    return "\n".join([line for line in shell(cmd=cmd, fail=fail, stderr=stderr, env=env)])
