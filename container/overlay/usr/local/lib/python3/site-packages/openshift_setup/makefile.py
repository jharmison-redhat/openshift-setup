import re

from pathlib import Path
from typing import Dict

class Makefile:
    _re_makevar = re.compile(r'^([a-zA-Z0-9_]+)[\s\t]*([:?]?[\+=]+)(.*?)([\\#]+.*)?$')
    _re_recurse = re.compile(r'\$\(([^)]+)\)')

    def __init__(self, makefile: Path = Path("Makefile"), starting_vars: Dict[str, str | None] = {}) -> None:
        if not makefile.exists():
            raise FileNotFoundError(f"No Makefile found at {makefile}")
        self.makefile = makefile
        self.vars = starting_vars
        self.parsed = False

    @staticmethod
    def _remove_comment(line: str, comment: str = "#") -> str:
        i = line.find(comment)
        if i >= 0:
            line = line[:i]
        return line.strip()

    def read(self) -> Dict[str, str | None]:
        if self.parsed:
            return self.vars
        with open(self.makefile) as f:
            data = f.readlines()
        name = ''
        for line in data:
            result = self._re_makevar.search(line)
            if result is None:
                continue

            name, oper, value, _comment = result.groups()
            if oper == '':
                continue
            if name is None:
                continue
            if name not in self.vars.keys():
                self.vars[name] = self._remove_comment(value)

        # Resolve every recursive assignment we can
        found_recursion = True
        while found_recursion:
            found_recursion = False
            for k, v in self.vars.items():
                if isinstance(v, str):
                    result = self._re_recurse.search(v)
                else:
                    continue
                if result is None:
                    continue
                replaceable, = result.groups()
                if replaceable in self.vars.keys():
                    found_recursion = True
                    new = self.vars[replaceable]
                    if new is not None:
                        self.vars[k] = v.replace(f'$({replaceable})', new)

        # Remove any values that are not helpful (make functions)
        clean = {}
        for k, v in self.vars.items():
            if isinstance(v, str):
                result = self._re_recurse.search(v)
            else:
                continue
            if result is None:
                clean[k] = v
        self.vars = clean
        self.parsed = True
        return clean
