import json
import yaml

from pathlib import Path
from pydantic import BaseModel as PydanticBaseModel
from string import Template
from typing import Any, Dict, List, Optional

from .utils import make_logger, merge
from .vars import vars

logger = make_logger()


class BaseModel(PydanticBaseModel):
    """A customized base class to reuse behaviors."""

    class PydanticEncoder(json.JSONEncoder):
        """Serialize Pydantic models.

        A JSONEncoder subclass that prepares Pydantic models for serialization.
        """

        def default(self, obj):
            """Encode model objects based on their type."""
            if isinstance(obj, BaseModel) and callable(obj.dict):
                return obj.dict(exclude_none=True)
            elif isinstance(obj, Path):
                return str(obj.resolve())
            elif isinstance(obj, set):
                return list(obj)
            return json.JSONEncoder.default(self, obj)

    @classmethod
    def from_yaml(cls, yaml_text: str) -> 'BaseModel':
        """Instantiate a BaseModel from a YAML string."""
        return cls.parse_obj(yaml.safe_load(yaml_text))

    def to_json(self) -> str:
        """Serialize a BaseModel as a JSON string."""
        return json.dumps(self, cls=self.PydanticEncoder)

    def to_yaml(self, *args, **kwargs) -> str:
        """Serialize a BaseModel as a YAML string."""
        if 'sort_keys' in kwargs:
            return yaml.dump(json.loads(self.json()), *args, **kwargs)
        else:
            return yaml.dump(json.loads(self.json()), *args, sort_keys=False, **kwargs)


class Namespace(BaseModel):
    """A representation of a Namespace being necessary for a demo."""
    name: str
    labels: Optional[Dict[str, str]] = None
    annotations: Optional[Dict[str, str]] = None

    def render(self, cluster_dir: Path | None = None) -> None:
        """Load an application for creating a Namespace."""
        if cluster_dir is None:
            if vars.get("CLUSTER_DIR") is None:
                raise RuntimeError("Unable to determine cluster directory")
            else:
                cluster_dir = Path(vars.get("CLUSTER_DIR", "/"))
        values: Dict[str, str | dict] = {"name": self.name}
        if self.labels is not None:
            values["labels"] = self.labels
        if self.annotations is not None:
            values["annotations"] = self.annotations

        app = Application(
            name="namespace",
            fileprefix=self.name,
            values=values,
            rewrite={
                "metadata": {
                    "name": f"{self.name}-namespace"
                }
            }
        )
        logger.debug(app)
        app.render(cluster_dir=cluster_dir)


class Application(BaseModel):
    """A representation of an ArgoCD application template and its associated chart values."""
    name: str
    fileprefix: Optional[str] = None
    rewrite: Dict[str, Any] = {}
    values: Dict[str, Any] = {}
    secrets: Dict[str, Any] = {}

    def load_template(self) -> Dict[str, Any]:
        """Load an ArgoCD Application Template and return its modified form."""
        app_template = Path("applications-templates").joinpath(f"{self.name}.yaml.tpl")
        with open(app_template) as f:
            template_data = Template(f.read())

        logger.debug("Loaded raw app:")
        logger.debug(template_data.safe_substitute())

        subs = {}
        for var in ["CLUSTER_URL", "ARGO_GIT_URL", "ARGO_GIT_REVISION"]:
            if vars.get(var) is not None:
                subs[var] = vars.get(var)
        logger.debug(f" Replacing: {subs}")
        template_data = template_data.safe_substitute(**subs)

        template = yaml.safe_load(template_data)

        if self.rewrite:
            logger.debug(f"Merging in: {self.rewrite}")
        template = merge(template, self.rewrite)

        logger.debug("Rendered app dict:")
        logger.debug(template)

        return template

    def render(self, cluster_dir: Path | None = None) -> None:
        if cluster_dir is None:
            if vars.get("CLUSTER_DIR") is None:
                raise RuntimeError("Unable to determine cluster directory")
            else:
                cluster_dir = Path(vars.get("CLUSTER_DIR", "/"))

        apps_dir = cluster_dir.joinpath("applications")
        apps_dir.mkdir(parents=True, exist_ok=True)

        cluster_yaml = cluster_dir.joinpath("cluster.yaml")
        value_files = []
        if cluster_yaml.exists():
            value_files.append(f"../../{cluster_dir}/cluster.yaml")

        if self.values:
            if self.fileprefix is None:
                values_dir = cluster_dir.joinpath("values").joinpath(self.name)
            else:
                values_dir = cluster_dir.joinpath("values").joinpath(f"{self.fileprefix}-{self.name}")
            values_dir.mkdir(parents=True, exist_ok=True)
            with open(values_dir.joinpath("values.yaml"), "w") as f:
                yaml.dump(self.values, f, explicit_start=True)
            value_files.append(f"../../{values_dir}/values.yaml")

        if self.secrets:
            if self.fileprefix is None:
                secrets_dir = cluster_dir.joinpath("values").joinpath(self.name)
            else:
                secrets_dir = cluster_dir.joinpath("values").joinpath(f"{self.fileprefix}-{self.name}")
            secrets_dir.mkdir(parents=True, exist_ok=True)
            with open(secrets_dir.joinpath("secrets.yaml"), "w") as f:
                yaml.dump(self.secrets, f, explicit_start=True)
            value_files.append(f"secrets+age-import:///helm-secrets-private-keys/argo.txt?../../{secrets_dir}/secrets.enc.yaml")

        if self.fileprefix is None:
            app_path = apps_dir.joinpath(f"{self.name}.yaml")
        else:
            app_path = apps_dir.joinpath(f"{self.fileprefix}-{self.name}.yaml")

        if value_files:
            self.rewrite = merge(self.rewrite, {
                "spec": {
                    "source": {
                        "helm": {
                            "valueFiles": value_files
                        }
                    }
                }
            })
        app = self.load_template()

        with open(app_path, "w") as f:
            yaml.dump(app, f, explicit_start=True)


class Demo(BaseModel):
    namespaces: List[Namespace] = []
    applications: List[Application] = []

    def render(self, cluster_dir: Path | None = None) -> None:
        if cluster_dir is None:
            if vars.get("CLUSTER_DIR") is None:
                raise RuntimeError("Unable to determine cluster directory")
            else:
                cluster_dir = Path(vars.get("CLUSTER_DIR", "/"))

        for namespace in self.namespaces:
            logger.debug(f"Rendering {namespace.name} namespace")
            namespace.render()
        for application in self.applications:
            logger.debug(f"Rendering {application.name} application")
            application.render()
