import json
import yaml

from functools import cached_property
from pathlib import Path
from pydantic import BaseModel as PydanticBaseModel
from string import Template
from typing import Any, Dict, List, Optional

from .secrets import encrypt
from .utils import make_logger, merge
from .vars import vars

logger = make_logger()


class BaseModel(PydanticBaseModel):
    """A customized base class to reuse behaviors."""

    class PydanticEncoder(json.JSONEncoder):
        """Serialize Pydantic models.

        A JSONEncoder subclass that prepares Pydantic models for serialization.
        """

        def default(self, obj):
            """Encode model objects based on their type."""
            if isinstance(obj, BaseModel) and callable(obj.dict):
                return obj.dict(exclude_none=True)
            elif isinstance(obj, Path):
                return str(obj.resolve())
            elif isinstance(obj, set):
                return list(obj)
            return json.JSONEncoder.default(self, obj)

    @classmethod
    def from_yaml(cls, yaml_text: str) -> 'BaseModel':
        """Instantiate a BaseModel from a YAML string."""
        return cls.parse_obj(yaml.safe_load(yaml_text))

    def to_json(self) -> str:
        """Serialize a BaseModel as a JSON string."""
        return json.dumps(self, cls=self.PydanticEncoder)

    def to_yaml(self, *args, **kwargs) -> str:
        """Serialize a BaseModel as a YAML string."""
        if 'sort_keys' in kwargs:
            return yaml.dump(json.loads(self.json()), *args, **kwargs)
        else:
            return yaml.dump(json.loads(self.json()), *args, sort_keys=False, **kwargs)


class Namespace(BaseModel):
    """A representation of a Namespace being necessary for a demo."""
    name: str
    labels: Optional[Dict[str, str]] = None
    annotations: Optional[Dict[str, str]] = None

    def render(self, cluster_dir: Path | None = None) -> None:
        """Load an application for creating a Namespace."""
        if cluster_dir is None:
            if vars.get("CLUSTER_DIR") is None:
                raise RuntimeError("Unable to determine cluster directory")
            else:
                cluster_dir = Path(vars.get("CLUSTER_DIR", "/"))
        values: Dict[str, str | dict] = {"name": self.name}
        if self.labels is not None:
            values["labels"] = self.labels
        if self.annotations is not None:
            values["annotations"] = self.annotations

        app = Application(
            name="namespace",
            fileprefix=self.name,
            values=values,
            rewrite={
                "metadata": {
                    "name": f"{self.name}-namespace"
                }
            }
        )
        logger.debug(app)
        app.render(cluster_dir=cluster_dir)


class Application(BaseModel):
    """A representation of an ArgoCD application template and its associated chart values."""
    name: str
    fileprefix: Optional[str] = None
    rewrite: Dict[str, Any] = {}
    values: Dict[str, Any] = {}
    secrets: Dict[str, Any] = {}

    @cached_property
    def app_template(self) -> Path:
        return Path("applications-templates").joinpath(f"{self.name}.yaml.tpl")

    @cached_property
    def unmerged_template(self) -> Dict[str, Any]:
        """Load an ArgoCD Application Template and return its modified form."""
        with open(self.app_template) as f:
            template_data = Template(f.read())

        logger.debug("Loaded raw app:")
        logger.debug(template_data.safe_substitute())

        subs = {}
        for var in ["CLUSTER_URL", "ARGO_GIT_URL", "ARGO_GIT_REVISION"]:
            provided = vars.get(var)
            if provided is not None:
                subs[var] = provided
        logger.debug(f" Replacing: {subs}")
        template_data = template_data.safe_substitute(**subs)
        template_dict = yaml.safe_load(template_data)
        logger.debug(f"App dict:")
        logger.debug(template_dict)

        return template_dict

    @cached_property
    def kind(self) -> Optional[str]:
        return self.unmerged_template.get("kind")

    @cached_property
    def is_application_set(self) -> bool:
        return self.kind == "ApplicationSet"

    def load_template(self) -> Dict[str, Any]:
        template = self.unmerged_template
        if self.rewrite:
            logger.debug(f"Merging in: {self.rewrite}")
            template = merge(template, self.rewrite)
        return template

    def render(self, cluster_dir: Path | None = None) -> None:
        if cluster_dir is None:
            if vars.get("CLUSTER_DIR") is None:
                raise RuntimeError("Unable to determine cluster directory")
            else:
                cluster_dir = Path(vars.get("CLUSTER_DIR", "/"))

        apps_dir = cluster_dir.joinpath("applications")
        apps_dir.mkdir(parents=True, exist_ok=True)

        # Modify paths as necessary if we're prefixing the app and values
        if self.fileprefix is None:
            app_path = apps_dir.joinpath(f"{self.name}.yaml")
            values_dir = cluster_dir.joinpath("values").joinpath(self.name)
        else:
            app_path = apps_dir.joinpath(f"{self.fileprefix}-{self.name}.yaml")
            values_dir = cluster_dir.joinpath("values").joinpath(f"{self.fileprefix}-{self.name}")

        values_yaml = values_dir.joinpath("values.yaml")
        secrets_yaml = values_dir.joinpath("secrets.yaml")
        secrets_enc_yaml = values_dir.joinpath("secrets.enc.yaml")

        # If values have been specified, overwrite them and track
        if self.values:
            logger.debug(f"Writing out {self.values} for {self.name}")
            values_dir.mkdir(parents=True, exist_ok=True)
            with open(values_yaml) as f:
                old = yaml.safe_load(f)
            new = merge(old, self.values)
            with open(values_yaml, "w") as f:
                yaml.dump(new, f, explicit_start=True)

        # If secrets have been specified, overwrite them and track
        if self.secrets:
            logger.debug(f"Writing out {self.secrets} for {self.name}")
            values_dir.mkdir(parents=True, exist_ok=True)
            with open(secrets_yaml) as f:
                old = yaml.safe_load(f)
            new = merge(old, self.secrets)
            with open(secrets_yaml, "w") as f:
                yaml.dump(new, f, explicit_start=True)

        if not self.is_application_set:
            # Keep track of generated or found values to add to the app
            value_files = []
            # Look for cluster-wide values to add
            cluster_yaml = cluster_dir.joinpath("cluster.yaml")
            if cluster_yaml.exists():
                logger.debug(f"Adding cluster.yaml values to {self.name}")
                value_files.append(f"../../{cluster_dir}/cluster.yaml")
            if values_yaml.exists():
                logger.debug(f"Adding values.yaml values to {self.name}")
                value_files.append(f"../../{values_dir}/values.yaml")
            if secrets_yaml.exists():
                logger.info(f"Encrypting {secrets_yaml}")
                if output := encrypt(secrets_yaml):
                    logger.info(output)
            if secrets_enc_yaml.exists():
                logger.debug(f"Adding secrets.enc.yaml values to {self.name}")
                value_files.append(f"secrets+age-import:///helm-secrets-private-keys/argo.txt?../../{values_dir}/secrets.enc.yaml")

            # If we identified any values to track, update the application to use them
            if value_files:
                self.rewrite = merge(self.rewrite, {
                    "spec": {
                        "source": {
                            "helm": {
                                "valueFiles": value_files
                            }
                        }
                    }
                })
        else:
            logger.warn(f"Skipping values merge for ApplicationSet")

        # Render out the app yaml and deserialize
        app = self.load_template()

        # Write the generated application yaml for the cluster
        with open(app_path, "w") as f:
            yaml.dump(app, f, explicit_start=True)


class Demo(BaseModel):
    namespaces: List[Namespace] = []
    applications: List[Application] = []

    def render(self, cluster_dir: Path | None = None) -> None:
        if cluster_dir is None:
            if vars.get("CLUSTER_DIR") is None:
                raise RuntimeError("Unable to determine cluster directory")
            else:
                cluster_dir = Path(vars.get("CLUSTER_DIR", "/"))

        for namespace in self.namespaces:
            logger.debug(f"Rendering {namespace.name} namespace")
            namespace.render()
        for application in self.applications:
            logger.debug(f"Rendering {application.name} application")
            application.render()
