import inspect
import os
import re
import typer

from pathlib import Path
from rich import print
from typer.main import get_command_name
from typing import Callable, Optional
from typing_extensions import Annotated

from .models import Application, Demo
from .utils import make_logger
from .vars import vars


def path_autocomplete(
        file_okay: bool = True,
        dir_okay: bool = True,
        writable: bool = False,
        readable: bool = True,
        allow_dash: bool = False,
        match_wildcard: Optional[str] = None,
) -> Callable[[str], list[str]]:
    def wildcard_match(string: str, pattern: str) -> bool:
        regex = re.escape(pattern).replace(r'\?', '.').replace(r'\*', '.*')
        return re.fullmatch(regex, string) is not None

    def completer(incomplete: str) -> list[str]:
        items = os.listdir()
        completions = []
        for item in items:
            if not file_okay and os.path.isfile(item):
                continue
            elif not dir_okay and os.path.isdir(item):
                continue

            if readable and not os.access(item, os.R_OK):
                continue
            if writable and not os.access(item, os.W_OK):
                continue

            completions.append(item)

        if allow_dash:
            completions.append('-')

        if match_wildcard is not None:
            completions = filter(lambda i: wildcard_match(i, match_wildcard), completions)

        return [i for i in completions if i.startswith(incomplete)]

    return completer


VerboseOption = Annotated[int, typer.Option(
    "--verbose", "-v", count=True,
    help="Increase logging verbosity (repeat for more)",
)]

DemoFile = Annotated[Path, typer.Argument(
    autocompletion=path_autocomplete(file_okay=True, dir_okay=False, match_wildcard="*.yaml"),
    help="The path of a demo file",
)]

AppTemplate = Annotated[Path, typer.Argument(
    autocompletion=path_autocomplete(file_okay=True, dir_okay=False, match_wildcard="*.yaml.tpl"),
    help="The path of an app template",
)]


class Cli:
    def __init__(self) -> None:
        self.run = typer.Typer(
            context_settings={"help_option_names": ["-h", "--help"]},
            no_args_is_help=True,
        )
        self.demo = typer.Typer(
            context_settings={"help_option_names": ["-h", "--help"]},
            no_args_is_help=True,
        )
        self.app = typer.Typer(
            context_settings={"help_option_names": ["-h", "--help"]},
            no_args_is_help=True,
        )
        self.run.add_typer(self.demo, name="demo", help="Work with demo definitions")
        self.run.add_typer(self.app, name="app", help="Work with ArgoCD applications")
        for method, func in inspect.getmembers(self, predicate=inspect.ismethod):
            # Put demo commands inside the group
            if method.startswith("cmd_demo_"):
                command_name = get_command_name(method.removeprefix("cmd_demo_"))
                self.demo.command(name=command_name)(func)
                continue
            # Put application commands inside the group
            if method.startswith("cmd_app_"):
                command_name = get_command_name(method.removeprefix("cmd_app_"))
                self.app.command(name=command_name)(func)
                continue
            # Put other commands at the root app
            if method.startswith("cmd_"):
                command_name = get_command_name(method.removeprefix("cmd_"))
                self.run.command(name=command_name)(func)

    def cmd_demo_validate(
        self,
        demo_file: DemoFile,
        verbose: VerboseOption = 0,
    ) -> None:
        """
        Validate a demo file and display its parsed data
        """
        logger = make_logger(verbose)
        logger.debug("Displaying demo")
        with open(demo_file) as f:
            demo = Demo.from_yaml(f.read())
        print(demo.model_dump())

    def cmd_demo_process(
        self,
        demo_file: DemoFile,
        verbose: VerboseOption = 0,
    ) -> None:
        """
        Process a demo for a cluster, generating the manifests to deploy it
        """
        logger = make_logger(verbose)
        logger.info(f"Rendering {demo_file} for {vars.get('CLUSTER_URL')}")
        with open(demo_file) as f:
            demo = Demo.from_yaml(f.read())
        demo.render()

    def cmd_app_process(
        self,
        app_template: AppTemplate,
        verbose: VerboseOption = 0,
    ) -> None:
        """
        Process an individual application template for a cluster, generating the manifests to deploy it
        """
        logger = make_logger(verbose)
        logger.info(f"Rendering {app_template} for {vars.get('CLUSTER_URL')}")
        app_name = app_template.parts[-1].split('.')[0]
        Application(name=app_name).render()

    def cmd_config(
        self,
        verbose: VerboseOption = 0,
    ) -> None:
        """
        Validate configuration loaded from the environment, env files, and defaults
        """
        logger = make_logger(verbose)
        logger.debug("Displaying config")
        print(dict(vars))
