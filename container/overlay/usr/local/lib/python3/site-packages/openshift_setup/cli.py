import inspect
import os
import re
import typer

from pathlib import Path
from typer.main import get_command_name
from typing import Callable, Optional
from typing_extensions import Annotated

from .models import Demo
from .utils import make_logger
from .vars import vars


def path_autocomplete(
        file_okay: bool = True,
        dir_okay: bool = True,
        writable: bool = False,
        readable: bool = True,
        allow_dash: bool = False,
        match_wildcard: Optional[str] = None,
) -> Callable[[str], list[str]]:
    def wildcard_match(string: str, pattern: str) -> bool:
        regex = re.escape(pattern).replace(r'\?', '.').replace(r'\*', '.*')
        return re.fullmatch(regex, string) is not None

    def completer(incomplete: str) -> list[str]:
        items = os.listdir()
        completions = []
        for item in items:
            if not file_okay and os.path.isfile(item):
                continue
            elif not dir_okay and os.path.isdir(item):
                continue

            if readable and not os.access(item, os.R_OK):
                continue
            if writable and not os.access(item, os.W_OK):
                continue

            completions.append(item)

        if allow_dash:
            completions.append('-')

        if match_wildcard is not None:
            completions = filter(lambda i: wildcard_match(i, match_wildcard), completions)

        return [i for i in completions if i.startswith(incomplete)]

    return completer


VerboseOption = Annotated[int, typer.Option(
    "--verbose", "-v", count=True,
    help="Increase logging verbosity (repeat for more)",
)]

DemoFile = Annotated[Path, typer.Argument(
    autocompletion=path_autocomplete(file_okay=True, dir_okay=False, match_wildcard="*.yaml"),
    help="The path of a demo file",
)]


class Cli:
    def __init__(self) -> None:
        self.run = typer.Typer(
            context_settings={"help_option_names": ["-h", "--help"]},
            no_args_is_help=True,
        )
        for method, func in inspect.getmembers(self, predicate=inspect.ismethod):
            if not method.startswith("cmd_"):
                continue
            command_name = get_command_name(method.removeprefix("cmd_"))
            self.run.command(name=command_name)(func)

    def cmd_display(
        self,
        demo_file: DemoFile,
        verbose: VerboseOption = 0,
    ) -> None:
        """
        Display the contents of a demo file, validating its schema while loading it
        """
        logger = make_logger(verbose)
        logger.debug("Displaying demo")
        from pprint import pprint
        with open(demo_file) as f:
            demo = Demo.from_yaml(f.read())
        pprint(demo.model_dump())

    def cmd_process(
        self,
        demo_file: DemoFile,
        verbose: VerboseOption = 0,
    ) -> None:
        """
        Process a demo for a cluster, generating the manifests to deploy it
        """
        logger = make_logger(verbose)
        logger.info(f"Rendering {demo_file} for {vars.get('CLUSTER_URL')}")
        with open(demo_file) as f:
            demo = Demo.from_yaml(f.read())
        demo.render()

    def cmd_check_config(
        self,
        verbose: VerboseOption = 0,
    ) -> None:
        """
        Check that our configuration has loaded correctly, printing all relevant variables loaded
        """
        logger = make_logger(verbose)
        logger.debug("Displaying config")
        from pprint import pprint
        pprint(dict(vars))
